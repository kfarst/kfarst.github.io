I"‰L<p><em>Check out <a href="http://kfarst.github.io/ios/2019/02/21/putting-your-view-controllers-on-a-diet-using-clean-swift-vip-architecture-part-2/">part 2</a> for more Clean Swift goodness</em></p>

<p>If you are just getting started in iOS development (or even have a decent amount of experience) you may
see situations where your view controllers are getting quite large. Maybe you‚Äôre finding all of the view setup,
presenting other view controllers, getting the user‚Äôs current location, and API calls are all defined and executed
within the view controller.</p>

<p>Not only are the view controllers getting unruly to update, if you were asked to write unit or UI tests, you might
be scratching your head trying to figure out how in the world to swap out your API and geolocation calls to use mocks
instead of the real thing. This can be especially daunting for someone just getting into the realm of testing their code,
and you can see from this example something needs to be done to make cleaner and easier to test code.</p>

<p>As you probably know, iOS apps are build using the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-View-Controller</a> (MVC) architecture. If your views are storyboards or programmatic UI code presented to the user, and models are for business logic, it seems like the only place left to put ‚Äúeverything else‚Äù would be the controller (or view controller in the case of iOS). There is a joke in the iOS community
that MVC actually stands for <em>Massive View Controller</em>, so you can see this is something that tends to naturally happen as you level up your dev skills in this mobile platform.</p>

<h3 id="its-not-your-fault">It‚Äôs Not Your Fault</h3>

<p>Before diving into one way of mitigating this situation, I wanted to take a second to talk about <em>how</em> and <em>why</em> this happens.
Now, there are a countless number of reasons which leads to this antipattern, but I wanted to highlight 3 to briefly address: <em>definition</em>, <em>education</em>, and <em>experience</em>.</p>

<h5 id="definition">Definition</h5>

<p>A <em>view controller</em>, or more simply a controller, can be described in the most basic terms as the ‚Äúglue‚Äù between view logic and business domain logic. More formal definitions can be much more specific and detailed, but unless you really delve into the topic,
the explanation of what a view controller does it actually pretty vague. If we think about it in on a high level, perhaps you
could say it does conform to the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>.
However, digging just a little deeper, we see that modern usage of the view controller in iOS is actually MUCH more complex. Just a few examples:</p>

<ul>
  <li>Not only is it responsible for presenting the UI, but needs to accept and process user input also.</li>
  <li>View setup can include composing subviews and how they interact, adjusting the constraints to fit the screen, passing any actual content to those views from the business logic, and updating those views based on events.</li>
  <li>Any protocols the view controller must conform to for services or features.</li>
  <li>Presenting or dismissing other view controllers.</li>
  <li>Direct access to its parent <code>UINavigationController</code>, <code>UITabBarController</code>, or some other container view controller.</li>
</ul>

<p>These examples aren‚Äôt custom, rare use-cases for an application either. Quite the opposite, you could find every single one of these examples in even the most trivial projects.</p>

<h5 id="education">Education</h5>

<p>Learning iOS development (including Swift and/or Objective-C) can be a daunting task. Because of this, often times beginner tutorials and even Apple‚Äôs own documentation and code examples take ‚Äúshortcuts‚Äù for the sake of brevity, ease of explanation,
or keeping a tutorial/video at a reasonable length. Many times these written or recorded references will come with a disclaimer
that the approach they are taking may not be using best practices, but this can unfortunately lead developers into composing
things in a less-than-ideal manner, especially if he or she is new to programming also.</p>

<p>What‚Äôs worse, these problems may start to become larger and larger ‚Äúpain points‚Äù as the application grows, and usually at that point
cleaning up the technical debt would require a large and time-consuming refactor. I don‚Äôt disagree with keeping teaching material and documentation as straight forward as possible so as to not cause confusion in the reader and ‚Äúget right to the point‚Äù of helping to solve
a problem, however it can lead to an unfortunate and unintended side effect.</p>

<h5 id="experience">Experience</h5>

<p>Elaborating on the section above, even senior engineers are constantly Googling things on a daily basis. However, what you do with that information is more of the intention I‚Äôm trying to convey when talking about <em>experience</em> rather than the number of years someone has been programming. This discernment isn‚Äôt even a matter of one search result being ‚Äúwrong‚Äù and another one being ‚Äúright‚Äù, but moreso:</p>

<ul>
  <li>Knowing what solution would work best in one sitatuion compared to another.</li>
  <li>Understanding the concept of the solution and being able to apply best practices or refactoring to fit the need.</li>
  <li>Sharpened ‚ÄúGoogle-fu‚Äù skills of how to structure the search query to narrow the search to the specific use case.</li>
</ul>

<p>Even experienced developers who are learning a new language or framework may have trouble at first if he or she doesn‚Äôt know the ‚Äúlingo‚Äù or terminology. With that understanding, it‚Äôs easy to see that even with the ‚Äúexperience to discern‚Äù, if you aren‚Äôt familiar with the subject material you don‚Äôt have a basis to judge what is best for a situation.</p>

<h2 id="back-to-our-regularly-scheduled-programming">Back to Our Regularly Scheduled Programming‚Ä¶.</h2>

<p>Now that we‚Äôve addressed the problem in detail, the question arises: <em>How do we solve this?</em> As the title of this post hinted, we‚Äôll be diving in to one particular <em>design pattern</em> that has recently gained popularity in the iOS development realm. However, I would be remiss to not first mention the <em>dozens</em> of other options as well. In terms of software architecture, the decisions made are largely subjective based on the situation, and even cut-and-dry design patterns or frameworks can often be combined with others to provide a better result.</p>

<p>That being said, the two options you should probably reach for first are the classic design patterns originally introduced in the book <a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns: Elements of Reusable Object-Oriented Software</a>, and the <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> principles. Using these as guides can greatly improve your object-oriented programming experience spanning across multiple languages and frameworks. Additionally, many other programming paradigms have sprung up as popular alternatives to the classic MVC structure that exists in iOS apps. These include (but are definitely not limited to):</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">Model-View-Presenter</a> (MVP)</li>
  <li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">Model-View-ViewModel</a> (MVVM)</li>
  <li><a href="https://www.objc.io/issues/13-architecture/viper/">View-Interactor-Presenter-Entity-Router</a> (VIPER)</li>
</ul>

<h2 id="clean-swift">Clean Swift</h2>

<p>The <a href="https://clean-swift.com/">Clean Swift</a> architecture, or View-Interactor-Presenter (VIP) is one such design pattern that has risen from the ashes of the broken MVC implementation of the iOS ecosystem. It frees up the view controller to do just that: <em>control the view</em>. As mentioned above, that includes two main responsibilities:</p>

<ol>
  <li>Responding to events (third-party, user interaction, view lifecycle hooks)</li>
  <li>Control what is shown on the screen (initial view setup and subsequent updates to that view)</li>
</ol>

<p>The problem of the <em>massive view controller</em> creeps in because it‚Äôs usually just easier to include the various dependencies of the controller directly in the class itself. Let‚Äôs say I want to kick off an API request when the <code>viewDidAppear(...)</code> method is called. I know that I need to provide a separate class or interface for the API, but then I just include the API interface directly in the view controller.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift">  <span class="nf">init</span><span class="p">(</span><span class="nv">myApiClient</span><span class="p">:</span> <span class="kt">ApiClient</span> <span class="o">=</span> <span class="kt">ApiClient</span><span class="p">())</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

  <span class="nf">viewDidAppear</span><span class="p">(</span><span class="n">_</span> <span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewDidAppear</span><span class="p">(</span><span class="n">animated</span><span class="p">)</span>

    <span class="n">myApiClient</span><span class="o">.</span><span class="nf">getList</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="p">}</span></code></pre></figure>

<p>This example is simple, but there are two important points to make:</p>

<ol>
  <li>
    <p>We are exposing implementation details to the view controller that it doesn‚Äôt need to know about. There isn‚Äôt too much more I can do for refactoring in this case, but if the API request had a more complicated setup it would continue exposing more and more implementation details that the view controller doesn‚Äôt need to know about.</p>
  </li>
  <li>
    <p>Including the API client in the view controller is just another dependency in the potentially large list of dependencies being pulled in to the same class. Even if the dependencies are included by way of optional properties, testing becomes more and more difficult as each dependency needs to either be included in such a way as to not conflict with other dependencies, or would need to be mocked or stubbed.</p>
  </li>
</ol>

<p>It would be much cleaner if every event the view controller had to handle could be passed off to an <strong>output</strong> to handle, and every time the view needed to be updated could be handled by a single <strong>input</strong>. Essentially, that‚Äôs what the View-Interactor-Presenter combination does. Events are passed off from the view controller to the interactor, the presenter takes the result of that work done and tells the view controller what should be updated in its view and how.</p>

<p><img src="https://imgur.com/xMDeTsR.png" width="100%" /></p>

<p>The view controller‚Äôs <strong>output</strong> is the interactor, the interactor‚Äôs <strong>output</strong> is the presenter, and finally the presenter‚Äôs <strong>output</strong> is the view controller again. In the way same, the ineractor‚Äôs <strong>input</strong> is the view controller, the presenter‚Äôs <strong>input</strong> is the interactor, and the view controller‚Äôs <strong>input</strong> is the presenter.</p>

<p>This loop of a connected controller-interactor-presenter is often called a <em>scene</em>, and each class in the scene is connected to its <strong>input</strong> and <strong>output</strong> through a <em>protocol</em>. Keep in mind with the example below, I named the protocol <code>OrdersViewControllerOutput</code> and the variable storing the interactor in the view controller <code>output</code>. However, feel free to name these as you see fit to avoid confusion. You could name them, for example, <code>OrdersBusinessLogic</code> and <code>interactor</code> if that would be clearer.</p>

<p><em>OrdersInteractor.swift</em></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">protocol</span> <span class="kt">OrderListViewControllerOutput</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">getOrderList</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">OrderListInteractor</span><span class="p">:</span> <span class="kt">OrderListViewControllerOutput</span> <span class="p">{</span>
  <span class="o">...</span>
  <span class="nf">getOrderList</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
  <span class="p">}</span></code></pre></figure>

<p><em>OrdersViewController.swift</em></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">OrderListViewController</span><span class="p">:</span> <span class="kt">ViewController</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">OrdersViewControllerOutput</span>

  <span class="nf">init</span><span class="p">(</span><span class="nv">output</span><span class="p">:</span> <span class="kt">OrdersViewControllerOutput</span> <span class="o">=</span> <span class="kt">OrdersInteractor</span><span class="p">())</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
  <span class="p">}</span>

  <span class="nf">viewDidAppear</span><span class="p">(</span><span class="n">_</span> <span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="n">output</span><span class="o">.</span><span class="nf">getOrderList</span><span class="p">()</span>
  <span class="p">}</span></code></pre></figure>

<p>There are two important aspects of this refactor I‚Äôd like to point out:</p>

<ol>
  <li>
    <p>There is no longer a need to pass in and manage individual dependencies from the view controller since the interactor will be handling the events and actions coming from the view controller. In fact, you don‚Äôt even need to pass the dependencies into the interactor either. Instead, one can also extract each unit of ‚Äúwork‚Äù along with its dependencies to worker classes that the interactor can call individually, but these will be discussed in part 2 of this post.</p>
  </li>
  <li>
    <p>Having an interactor that conforms to a protocol makes mocking it for the sake of testing much easier. The mocked interactor class can be passed into the view controller, and validating that each method of the interactor is called by the view controller becomes trivial.</p>
  </li>
</ol>

<p><em>OrderListInteractorMock.swift</em></p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">OrderListInteractorMock</span><span class="p">:</span> <span class="kt">OrderListViewControllerOutput</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">getOrdersListCalled</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="k">var</span> <span class="nv">getSomeOtherFunctionCalled</span> <span class="o">=</span> <span class="kc">false</span>

  <span class="kd">func</span> <span class="nf">getOrdersList</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">getOrdersListCalled</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">someOtherFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">getSomeOtherFunctionCalled</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h3 id="passing-data-in-the-vip-cycle">Passing Data In The VIP Cycle</h3>

<p>We still have a lot to cover in upcoming articles, but the last thing I‚Äôd like to talk about in part 1 is how data is passed between the various methods in the VIP cycle. Rather than passing each argument into a method, we can build <em>models</em> for our <em>scene</em>. These models are just basic <em>structs</em> for the purpose of ‚Äúpackaging‚Äù the arguments into a single data structure. The view controller passes a <strong>request</strong> to the interactor, the interactor passes a <strong>response</strong> to the presenter, and finaly the presenter passes a <strong>view model</strong> back to the view controller.</p>

<p><img src="https://imgur.com/L5ioLcf.png" width="100%" /></p>

<p>In code, the models look something like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">OrderList</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="kt">Request</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">start</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">end</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="p">}</span>

  <span class="kd">struct</span> <span class="kt">Response</span> <span class="p">{</span>
    <span class="o">...</span>
  <span class="p">}</span>

  <span class="kd">struct</span> <span class="kt">ViewModel</span> <span class="p">{</span>
    <span class="o">...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Now the <code>OrderListViewControllerOutput</code> can update its method signature to accept a <code>OrderList.Request</code> struct.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift">  <span class="kd">protocol</span> <span class="kt">OrdersViewControllerOutput</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">getOrderList</span><span class="p">(</span><span class="n">_</span> <span class="nv">request</span><span class="p">:</span> <span class="kt">OrderList</span><span class="o">.</span><span class="kt">Request</span><span class="p">)</span>
  <span class="p">}</span></code></pre></figure>

<p>Passing data in this way provides two key advantages:</p>

<ol>
  <li>
    <p>If an additional argument is needed, you only need to update the <code>OrderList</code> models instead of the method signature and protocol definitions.</p>
  </li>
  <li>
    <p>Having to mock a simple data structure compared to multiple argument objecs is much simpler when writing tests.</p>
  </li>
</ol>

<h2 id="to-be-continued">To Be Continued‚Ä¶</h2>

<p>As I mentioned above, in <a href="http://kfarst.github.io/ios/2019/02/21/putting-your-view-controllers-on-a-diet-using-clean-swift-vip-architecture-part-2/">upcoming articles</a> we will also be examining presenters, workers, routers, unit testing, and much more. I hope learning about Clean Swift has been an intriguing and exciting topic, and I look forward to expanding on it in my next few posts. Happy New Year, and happy coding!</p>
:ET